// @generated by protobuf-ts 1.0.13 with parameters long_type_string,optimize_code_size,generate_dependencies,optimize_code_size
// @generated from protobuf file "emote/v1/emote.proto" (package "protocol.emote.v1", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { MethodInfo } from "@protobuf-ts/runtime-rpc";
import { EquipEmotePackResponse } from "./types";
import { EquipEmotePackRequest } from "./types";
import { DequipEmotePackResponse } from "./types";
import { DequipEmotePackRequest } from "./types";
import { DeleteEmoteFromPackResponse } from "./types";
import { DeleteEmoteFromPackRequest } from "./types";
import { DeleteEmotePackResponse } from "./types";
import { DeleteEmotePackRequest } from "./types";
import { AddEmoteToPackResponse } from "./types";
import { AddEmoteToPackRequest } from "./types";
import { GetEmotePackEmotesResponse } from "./types";
import { GetEmotePackEmotesRequest } from "./types";
import { GetEmotePacksResponse } from "./types";
import { GetEmotePacksRequest } from "./types";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { CreateEmotePackResponse } from "./types";
import { CreateEmotePackRequest } from "./types";
import { UnaryCall } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Harmony's Emote service manages the emotes and emote packs.
 *
 * @generated from protobuf service protocol.emote.v1.EmoteService
 */
export interface IEmoteServiceClient {
    /**
     * Endpoint to create an emote pack.
     *
     * @generated from protobuf rpc: CreateEmotePack(protocol.emote.v1.CreateEmotePackRequest) returns (protocol.emote.v1.CreateEmotePackResponse);
     */
    createEmotePack(input: CreateEmotePackRequest, options?: RpcOptions): UnaryCall<CreateEmotePackRequest, CreateEmotePackResponse>;
    /**
     * Endpoint to get the emote packs you have equipped.
     *
     * @generated from protobuf rpc: GetEmotePacks(protocol.emote.v1.GetEmotePacksRequest) returns (protocol.emote.v1.GetEmotePacksResponse);
     */
    getEmotePacks(input: GetEmotePacksRequest, options?: RpcOptions): UnaryCall<GetEmotePacksRequest, GetEmotePacksResponse>;
    /**
     * Endpoint to get the emotes in an emote pack.
     *
     * @generated from protobuf rpc: GetEmotePackEmotes(protocol.emote.v1.GetEmotePackEmotesRequest) returns (protocol.emote.v1.GetEmotePackEmotesResponse);
     */
    getEmotePackEmotes(input: GetEmotePackEmotesRequest, options?: RpcOptions): UnaryCall<GetEmotePackEmotesRequest, GetEmotePackEmotesResponse>;
    /**
     * Endpoint to add an emote to an emote pack that you own.
     *
     * @generated from protobuf rpc: AddEmoteToPack(protocol.emote.v1.AddEmoteToPackRequest) returns (protocol.emote.v1.AddEmoteToPackResponse);
     */
    addEmoteToPack(input: AddEmoteToPackRequest, options?: RpcOptions): UnaryCall<AddEmoteToPackRequest, AddEmoteToPackResponse>;
    /**
     * Endpoint to delete an emote pack that you own.
     *
     * @generated from protobuf rpc: DeleteEmotePack(protocol.emote.v1.DeleteEmotePackRequest) returns (protocol.emote.v1.DeleteEmotePackResponse);
     */
    deleteEmotePack(input: DeleteEmotePackRequest, options?: RpcOptions): UnaryCall<DeleteEmotePackRequest, DeleteEmotePackResponse>;
    /**
     * Endpoint to delete an emote from an emote pack.
     *
     * @generated from protobuf rpc: DeleteEmoteFromPack(protocol.emote.v1.DeleteEmoteFromPackRequest) returns (protocol.emote.v1.DeleteEmoteFromPackResponse);
     */
    deleteEmoteFromPack(input: DeleteEmoteFromPackRequest, options?: RpcOptions): UnaryCall<DeleteEmoteFromPackRequest, DeleteEmoteFromPackResponse>;
    /**
     * Endpoint to dequip an emote pack that you have equipped.
     *
     * @generated from protobuf rpc: DequipEmotePack(protocol.emote.v1.DequipEmotePackRequest) returns (protocol.emote.v1.DequipEmotePackResponse);
     */
    dequipEmotePack(input: DequipEmotePackRequest, options?: RpcOptions): UnaryCall<DequipEmotePackRequest, DequipEmotePackResponse>;
    /**
     * Endpoint to equip an emote pack.
     *
     * @generated from protobuf rpc: EquipEmotePack(protocol.emote.v1.EquipEmotePackRequest) returns (protocol.emote.v1.EquipEmotePackResponse);
     */
    equipEmotePack(input: EquipEmotePackRequest, options?: RpcOptions): UnaryCall<EquipEmotePackRequest, EquipEmotePackResponse>;
}
/**
 * Harmony's Emote service manages the emotes and emote packs.
 *
 * @generated from protobuf service protocol.emote.v1.EmoteService
 */
export class EmoteServiceClient implements IEmoteServiceClient {
    readonly typeName = "protocol.emote.v1.EmoteService";
    readonly methods: MethodInfo[] = [
        { service: this, name: "CreateEmotePack", localName: "createEmotePack", I: CreateEmotePackRequest, O: CreateEmotePackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "GetEmotePacks", localName: "getEmotePacks", I: GetEmotePacksRequest, O: GetEmotePacksResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "GetEmotePackEmotes", localName: "getEmotePackEmotes", I: GetEmotePackEmotesRequest, O: GetEmotePackEmotesResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "AddEmoteToPack", localName: "addEmoteToPack", I: AddEmoteToPackRequest, O: AddEmoteToPackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "DeleteEmotePack", localName: "deleteEmotePack", I: DeleteEmotePackRequest, O: DeleteEmotePackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "DeleteEmoteFromPack", localName: "deleteEmoteFromPack", I: DeleteEmoteFromPackRequest, O: DeleteEmoteFromPackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "DequipEmotePack", localName: "dequipEmotePack", I: DequipEmotePackRequest, O: DequipEmotePackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } },
        { service: this, name: "EquipEmotePack", localName: "equipEmotePack", I: EquipEmotePackRequest, O: EquipEmotePackResponse, options: { "protocol.harmonytypes.v1.metadata": { requiresAuthentication: true } } }
    ];
    constructor(private readonly _transport: RpcTransport) {
    }
    createEmotePack(input: CreateEmotePackRequest, options?: RpcOptions): UnaryCall<CreateEmotePackRequest, CreateEmotePackResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<CreateEmotePackRequest, CreateEmotePackResponse>("unary", this._transport, method, opt, i);
    }
    getEmotePacks(input: GetEmotePacksRequest, options?: RpcOptions): UnaryCall<GetEmotePacksRequest, GetEmotePacksResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<GetEmotePacksRequest, GetEmotePacksResponse>("unary", this._transport, method, opt, i);
    }
    getEmotePackEmotes(input: GetEmotePackEmotesRequest, options?: RpcOptions): UnaryCall<GetEmotePackEmotesRequest, GetEmotePackEmotesResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<GetEmotePackEmotesRequest, GetEmotePackEmotesResponse>("unary", this._transport, method, opt, i);
    }
    addEmoteToPack(input: AddEmoteToPackRequest, options?: RpcOptions): UnaryCall<AddEmoteToPackRequest, AddEmoteToPackResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<AddEmoteToPackRequest, AddEmoteToPackResponse>("unary", this._transport, method, opt, i);
    }
    deleteEmotePack(input: DeleteEmotePackRequest, options?: RpcOptions): UnaryCall<DeleteEmotePackRequest, DeleteEmotePackResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<DeleteEmotePackRequest, DeleteEmotePackResponse>("unary", this._transport, method, opt, i);
    }
    deleteEmoteFromPack(input: DeleteEmoteFromPackRequest, options?: RpcOptions): UnaryCall<DeleteEmoteFromPackRequest, DeleteEmoteFromPackResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<DeleteEmoteFromPackRequest, DeleteEmoteFromPackResponse>("unary", this._transport, method, opt, i);
    }
    dequipEmotePack(input: DequipEmotePackRequest, options?: RpcOptions): UnaryCall<DequipEmotePackRequest, DequipEmotePackResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<DequipEmotePackRequest, DequipEmotePackResponse>("unary", this._transport, method, opt, i);
    }
    equipEmotePack(input: EquipEmotePackRequest, options?: RpcOptions): UnaryCall<EquipEmotePackRequest, EquipEmotePackResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<EquipEmotePackRequest, EquipEmotePackResponse>("unary", this._transport, method, opt, i);
    }
}
