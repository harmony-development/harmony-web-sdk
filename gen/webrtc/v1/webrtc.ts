// @generated by protobuf-ts 2.2.2 with parameter long_type_string,optimize_code_size,generate_dependencies,optimize_code_size
// @generated from protobuf file "webrtc/v1/webrtc.proto" (package "protocol.webrtc.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * A TURN server
 *
 * @generated from protobuf message protocol.webrtc.v1.TurnServer
 */
export interface TurnServer {
    /**
     * The hostname of the server
     *
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * The username to provide for the server
     *
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * The password for the server
     *
     * @generated from protobuf field: string password = 3;
     */
    password: string;
    /**
     * The port for the server
     *
     * @generated from protobuf field: uint32 port = 4;
     */
    port: number;
}
/**
 * An ICE candidate
 *
 * @generated from protobuf message protocol.webrtc.v1.IceCandidate
 */
export interface IceCandidate {
    /**
     * The MID, or Media Stream ID.
     *
     * @generated from protobuf field: string sdp_mid = 1;
     */
    sdpMid: string;
    /**
     * The index of the m-line describing the media associated with this candidate.
     *
     * @generated from protobuf field: string sdp_mline_index = 2;
     */
    sdpMlineIndex: string;
    /**
     * The candidate, in textual form, for passing to a WebRTC library.
     * A blank candidate indicates no further candidates are coming.
     *
     * @generated from protobuf field: string candidate = 3;
     */
    candidate: string;
}
/**
 * An incoming message from the WebRTC service
 *
 * @generated from protobuf message protocol.webrtc.v1.WebRTCResponse
 */
export interface WebRTCResponse {
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "turnServer";
        /**
         * There is a new TURN server you should use for initiating calls
         *
         * @generated from protobuf field: protocol.webrtc.v1.TurnServer turn_server = 1;
         */
        turnServer: TurnServer;
    } | {
        oneofKind: "iceCandidate";
        /**
         * There is a new remote ICE candidate
         *
         * @generated from protobuf field: protocol.webrtc.v1.IceCandidate ice_candidate = 2;
         */
        iceCandidate: IceCandidate;
    } | {
        oneofKind: "sdpOffer";
        /**
         * The remote has an SDP offer for you
         *
         * @generated from protobuf field: protocol.webrtc.v1.SDP sdp_offer = 3;
         */
        sdpOffer: SDP;
    } | {
        oneofKind: "sdpAnswer";
        /**
         * The remote has an SDP answer for you
         *
         * @generated from protobuf field: protocol.webrtc.v1.SDP sdp_answer = 4;
         */
        sdpAnswer: SDP;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The initialisation message for the WebRTC rpc. This should be sent first.
 *
 * @generated from protobuf message protocol.webrtc.v1.Init
 */
export interface Init {
    /**
     * The "session" you want to connect to.
     *
     * Various APIs in Harmony will give you session IDs,
     * which should be used in this API.
     *
     * @generated from protobuf field: uint64 session_id = 1;
     */
    sessionId: string;
}
/**
 * A session description for WebRTC
 *
 * @generated from protobuf message protocol.webrtc.v1.SDP
 */
export interface SDP {
    /**
     * The SDP
     *
     * @generated from protobuf field: string sdp = 1;
     */
    sdp: string;
}
/**
 * The request for WebRTC.
 *
 * @generated from protobuf message protocol.webrtc.v1.WebRTCRequest
 */
export interface WebRTCRequest {
    /**
     * @generated from protobuf oneof: request
     */
    request: {
        oneofKind: "init";
        /**
         * Initialise the stream
         *
         * @generated from protobuf field: protocol.webrtc.v1.Init init = 1;
         */
        init: Init;
    } | {
        oneofKind: "sdpOffer";
        /**
         * Send an SDP as an offer
         *
         * @generated from protobuf field: protocol.webrtc.v1.SDP sdp_offer = 2;
         */
        sdpOffer: SDP;
    } | {
        oneofKind: "sdpAnswer";
        /**
         * Send an SDP as an answer
         *
         * @generated from protobuf field: protocol.webrtc.v1.SDP sdp_answer = 3;
         */
        sdpAnswer: SDP;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class TurnServer$Type extends MessageType<TurnServer> {
    constructor() {
        super("protocol.webrtc.v1.TurnServer", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.TurnServer
 */
export const TurnServer = new TurnServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IceCandidate$Type extends MessageType<IceCandidate> {
    constructor() {
        super("protocol.webrtc.v1.IceCandidate", [
            { no: 1, name: "sdp_mid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp_mline_index", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "candidate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.IceCandidate
 */
export const IceCandidate = new IceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebRTCResponse$Type extends MessageType<WebRTCResponse> {
    constructor() {
        super("protocol.webrtc.v1.WebRTCResponse", [
            { no: 1, name: "turn_server", kind: "message", oneof: "event", T: () => TurnServer },
            { no: 2, name: "ice_candidate", kind: "message", oneof: "event", T: () => IceCandidate },
            { no: 3, name: "sdp_offer", kind: "message", oneof: "event", T: () => SDP },
            { no: 4, name: "sdp_answer", kind: "message", oneof: "event", T: () => SDP }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.WebRTCResponse
 */
export const WebRTCResponse = new WebRTCResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Init$Type extends MessageType<Init> {
    constructor() {
        super("protocol.webrtc.v1.Init", [
            { no: 1, name: "session_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.Init
 */
export const Init = new Init$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDP$Type extends MessageType<SDP> {
    constructor() {
        super("protocol.webrtc.v1.SDP", [
            { no: 1, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.SDP
 */
export const SDP = new SDP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebRTCRequest$Type extends MessageType<WebRTCRequest> {
    constructor() {
        super("protocol.webrtc.v1.WebRTCRequest", [
            { no: 1, name: "init", kind: "message", oneof: "request", T: () => Init },
            { no: 2, name: "sdp_offer", kind: "message", oneof: "request", T: () => SDP },
            { no: 3, name: "sdp_answer", kind: "message", oneof: "request", T: () => SDP }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message protocol.webrtc.v1.WebRTCRequest
 */
export const WebRTCRequest = new WebRTCRequest$Type();
/**
 * @generated ServiceType for protobuf service protocol.webrtc.v1.WebRTCService
 */
export const WebRTCService = new ServiceType("protocol.webrtc.v1.WebRTCService", [
    { name: "WebRTC", serverStreaming: true, clientStreaming: true, options: {}, I: WebRTCRequest, O: WebRTCResponse }
]);
