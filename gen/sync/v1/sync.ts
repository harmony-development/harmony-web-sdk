// @generated by protobuf-ts 1.0.13 with parameters long_type_string,optimize_code_size,generate_dependencies,optimize_code_size
// @generated from protobuf file "sync/v1/sync.proto" (package "protocol.sync.v1", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { MethodInfo } from "@protobuf-ts/runtime-rpc";
import { MessageType } from "@protobuf-ts/runtime";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { Empty } from "../../google/protobuf/empty";
import { UnaryCall } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Authentication data that will be sent in a `harmonytypes.v1.Token`.
 *
 * @generated from protobuf message protocol.sync.v1.AuthData
 */
export interface AuthData {
    /**
     * The server name of the server initiating the transaction. For Pull,
     * this tells the server being connected to which homeservers' events it should send.
     * For Push, this tells the server being connected to which homeservers' events it is
     * receiving.
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * The UTC UNIX time in seconds of when the request is started. Servers should reject
     * tokens with a time too far from the current time, at their discretion. A recommended
     * variance is 1 minute.
     *
     * @generated from protobuf field: uint64 time = 2;
     */
    time: string;
}
/**
 * @generated from protobuf message protocol.sync.v1.EventQueue
 */
export interface EventQueue {
    /**
     * @generated from protobuf field: repeated protocol.sync.v1.Event events = 1;
     */
    events: Event[];
}
/**
 * @generated from protobuf message protocol.sync.v1.Event
 */
export interface Event {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "userRemovedFromGuild";
        /**
         * @generated from protobuf field: protocol.sync.v1.Event.UserRemovedFromGuild user_removed_from_guild = 1;
         */
        userRemovedFromGuild: Event_UserRemovedFromGuild;
    } | {
        oneofKind: "userAddedToGuild";
        /**
         * @generated from protobuf field: protocol.sync.v1.Event.UserAddedToGuild user_added_to_guild = 2;
         */
        userAddedToGuild: Event_UserAddedToGuild;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message protocol.sync.v1.Event.UserRemovedFromGuild
 */
export interface Event_UserRemovedFromGuild {
    /**
     * @generated from protobuf field: uint64 user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: uint64 guild_id = 2;
     */
    guildId: string;
}
/**
 * @generated from protobuf message protocol.sync.v1.Event.UserAddedToGuild
 */
export interface Event_UserAddedToGuild {
    /**
     * @generated from protobuf field: uint64 user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: uint64 guild_id = 2;
     */
    guildId: string;
}
/**
 * # Postbox
 *
 * The postbox service forms the core of Harmony's server <-> server communications.
 *
 * It concerns the transfer of Events between servers, as well as ensuring reliable
 * delivery of them.
 *
 * The semantics of events are documented in the event types. The postbox service
 * is solely reliable for reliable pushing and pulling.
 *
 * ## Authorisation
 *
 * Requests are authorised using a serialized `harmonytypes.v1.Token` in the Authorization HTTP header.
 * The `data` field of the token will be a serialized `AuthData` message.
 * The private key used to sign is the homeserver's private key.
 *
 * ## Events
 *
 * In this section, we will use sender and recipient to refer to the servers
 * sending the events and the server receiving the events respectively.
 *
 * At PostboxService startup, a sender should first Pull all receivers it had
 * federated from before. If a receiver makes a Push to the sender while a Pull
 * is going on, the Push should be processed after the Pull is completed.
 *
 * The sender will attempt to Push to the receiver. If the Push RPC fails more
 * than X times (a recommended retry count is 5), the event will be dispatched
 * to the sender's queue for the receiver. Unless the receiver pulls these events,
 * all new events should be dispatched to the queue. No new Push RPC should be made
 * before the queue is emptied. This ensures that events are always received in the
 * right order.
 *
 * It is recommended that receivers try pulling periodically, for example, every
 * 1 minute after the last Push RPC by the sender. This ensures that events are recieved.
 *
 * @generated from protobuf service protocol.sync.v1.PostboxService
 */
export interface IPostboxServiceClient {
    /**
     * @generated from protobuf rpc: Pull(google.protobuf.Empty) returns (protocol.sync.v1.EventQueue);
     */
    pull(input: Empty, options?: RpcOptions): UnaryCall<Empty, EventQueue>;
    /**
     * @generated from protobuf rpc: Push(protocol.sync.v1.Event) returns (google.protobuf.Empty);
     */
    push(input: Event, options?: RpcOptions): UnaryCall<Event, Empty>;
}
/**
 * Type for protobuf message protocol.sync.v1.AuthData
 */
class AuthData$Type extends MessageType<AuthData> {
    constructor() {
        super("protocol.sync.v1.AuthData", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const AuthData = new AuthData$Type();
/**
 * Type for protobuf message protocol.sync.v1.EventQueue
 */
class EventQueue$Type extends MessageType<EventQueue> {
    constructor() {
        super("protocol.sync.v1.EventQueue", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
}
export const EventQueue = new EventQueue$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event
 */
class Event$Type extends MessageType<Event> {
    constructor() {
        super("protocol.sync.v1.Event", [
            { no: 1, name: "user_removed_from_guild", kind: "message", oneof: "kind", T: () => Event_UserRemovedFromGuild },
            { no: 2, name: "user_added_to_guild", kind: "message", oneof: "kind", T: () => Event_UserAddedToGuild }
        ]);
    }
}
export const Event = new Event$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event.UserRemovedFromGuild
 */
class Event_UserRemovedFromGuild$Type extends MessageType<Event_UserRemovedFromGuild> {
    constructor() {
        super("protocol.sync.v1.Event.UserRemovedFromGuild", [
            { no: 1, name: "user_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "guild_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const Event_UserRemovedFromGuild = new Event_UserRemovedFromGuild$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event.UserAddedToGuild
 */
class Event_UserAddedToGuild$Type extends MessageType<Event_UserAddedToGuild> {
    constructor() {
        super("protocol.sync.v1.Event.UserAddedToGuild", [
            { no: 1, name: "user_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "guild_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const Event_UserAddedToGuild = new Event_UserAddedToGuild$Type();
/**
 * # Postbox
 *
 * The postbox service forms the core of Harmony's server <-> server communications.
 *
 * It concerns the transfer of Events between servers, as well as ensuring reliable
 * delivery of them.
 *
 * The semantics of events are documented in the event types. The postbox service
 * is solely reliable for reliable pushing and pulling.
 *
 * ## Authorisation
 *
 * Requests are authorised using a serialized `harmonytypes.v1.Token` in the Authorization HTTP header.
 * The `data` field of the token will be a serialized `AuthData` message.
 * The private key used to sign is the homeserver's private key.
 *
 * ## Events
 *
 * In this section, we will use sender and recipient to refer to the servers
 * sending the events and the server receiving the events respectively.
 *
 * At PostboxService startup, a sender should first Pull all receivers it had
 * federated from before. If a receiver makes a Push to the sender while a Pull
 * is going on, the Push should be processed after the Pull is completed.
 *
 * The sender will attempt to Push to the receiver. If the Push RPC fails more
 * than X times (a recommended retry count is 5), the event will be dispatched
 * to the sender's queue for the receiver. Unless the receiver pulls these events,
 * all new events should be dispatched to the queue. No new Push RPC should be made
 * before the queue is emptied. This ensures that events are always received in the
 * right order.
 *
 * It is recommended that receivers try pulling periodically, for example, every
 * 1 minute after the last Push RPC by the sender. This ensures that events are recieved.
 *
 * @generated from protobuf service protocol.sync.v1.PostboxService
 */
export class PostboxServiceClient implements IPostboxServiceClient {
    readonly typeName = "protocol.sync.v1.PostboxService";
    readonly methods: MethodInfo[] = [
        { service: this, name: "Pull", localName: "pull", I: Empty, O: EventQueue },
        { service: this, name: "Push", localName: "push", I: Event, O: Empty }
    ];
    constructor(private readonly _transport: RpcTransport) {
    }
    pull(input: Empty, options?: RpcOptions): UnaryCall<Empty, EventQueue> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<Empty, EventQueue>("unary", this._transport, method, opt, i);
    }
    push(input: Event, options?: RpcOptions): UnaryCall<Event, Empty> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<Event, Empty>("unary", this._transport, method, opt, i);
    }
}
