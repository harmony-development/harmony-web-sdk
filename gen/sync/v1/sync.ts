// @generated by protobuf-ts 1.0.13 with parameters long_type_string,optimize_code_size,generate_dependencies,optimize_code_size
// @generated from protobuf file "sync/v1/sync.proto" (package "protocol.sync.v1", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { MethodInfo } from "@protobuf-ts/runtime-rpc";
import { MessageType } from "@protobuf-ts/runtime";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { UnaryCall } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Authentication data that will be sent in a `harmonytypes.v1.Token`.
 *
 * @generated from protobuf message protocol.sync.v1.AuthData
 */
export interface AuthData {
    /**
     * The server ID of the server initiating the transaction. For Pull,
     * this tells the server being connected to which homeservers' events it should send.
     * For Push, this tells the server being connected to which homeservers' events it is
     * receiving.
     *
     * @generated from protobuf field: string server_id = 1;
     */
    serverId: string;
    /**
     * The UTC UNIX time in seconds of when the request is started. Servers should reject
     * tokens with a time too far from the current time, at their discretion. A recommended
     * variance is 1 minute.
     *
     * @generated from protobuf field: uint64 time = 2;
     */
    time: string;
}
/**
 * Object representing a postbox event.
 *
 * @generated from protobuf message protocol.sync.v1.Event
 */
export interface Event {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "userRemovedFromGuild";
        /**
         * User removed from a guild.
         *
         * @generated from protobuf field: protocol.sync.v1.Event.UserRemovedFromGuild user_removed_from_guild = 1;
         */
        userRemovedFromGuild: Event_UserRemovedFromGuild;
    } | {
        oneofKind: "userAddedToGuild";
        /**
         * User added to a guild.
         *
         * @generated from protobuf field: protocol.sync.v1.Event.UserAddedToGuild user_added_to_guild = 2;
         */
        userAddedToGuild: Event_UserAddedToGuild;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Event sent when a user is removed from a guild.
 *
 * @generated from protobuf message protocol.sync.v1.Event.UserRemovedFromGuild
 */
export interface Event_UserRemovedFromGuild {
    /**
     * User ID of the user that was removed.
     *
     * @generated from protobuf field: uint64 user_id = 1;
     */
    userId: string;
    /**
     * Guild ID of the guild where the user was.
     *
     * @generated from protobuf field: uint64 guild_id = 2;
     */
    guildId: string;
}
/**
 * Event sent when a user is added to a guild.
 *
 * @generated from protobuf message protocol.sync.v1.Event.UserAddedToGuild
 */
export interface Event_UserAddedToGuild {
    /**
     * User ID of the user that was added.
     *
     * @generated from protobuf field: uint64 user_id = 1;
     */
    userId: string;
    /**
     * Guild ID of the guild where the user will be.
     *
     * @generated from protobuf field: uint64 guild_id = 2;
     */
    guildId: string;
}
/**
 * Used in `Pull` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.PullRequest
 */
export interface PullRequest {
}
/**
 * Used in `Pull` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.PullResponse
 */
export interface PullResponse {
    /**
     * The events that were not processed yet.
     *
     * @generated from protobuf field: repeated protocol.sync.v1.Event event_queue = 1;
     */
    eventQueue: Event[];
}
/**
 * Used in `Push` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.PushRequest
 */
export interface PushRequest {
    /**
     * The event to push to the server.
     *
     * @generated from protobuf field: protocol.sync.v1.Event event = 1;
     */
    event?: Event;
}
/**
 * Used in `Push` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.PushResponse
 */
export interface PushResponse {
}
/**
 * Used in `NotifyNewId` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.NotifyNewIdRequest
 */
export interface NotifyNewIdRequest {
    /**
     * The new server ID of the server.
     *
     * @generated from protobuf field: string new_server_id = 1;
     */
    newServerId: string;
}
/**
 * Used in `NotifyNewId` endpoint.
 *
 * @generated from protobuf message protocol.sync.v1.NotifyNewIdResponse
 */
export interface NotifyNewIdResponse {
}
/**
 * # Postbox
 *
 * The postbox service forms the core of Harmony's server <-> server communications.
 *
 * It concerns the transfer of Events between servers, as well as ensuring reliable
 * delivery of them.
 *
 * The semantics of events are documented in the event types. The postbox service
 * is solely reliable for reliable pushing and pulling.
 *
 * ## Server Identification
 *
 * Servers are identified using their domain, and the port which they serve. This is
 * called the "server ID", and must be formatted as `domain:port`. The port is NOT
 * optional. Converting this ID to a URL for communicating can simply be done via
 * prefixing the ID with a protocol, eg. `https://`.
 *
 * ## Authorisation
 *
 * Requests are authorised using a serialized `harmonytypes.v1.Token` in the Authorization HTTP header.
 * The `data` field of the token will be a serialized `AuthData` message.
 * The private key used to sign is the homeserver's private key.
 *
 * ## Events
 *
 * In this section, we will use sender and recipient to refer to the servers
 * sending the events and the server receiving the events respectively.
 *
 * At PostboxService startup, a sender should first Pull all receivers it had
 * federated from before. If a receiver makes a Push to the sender while a Pull
 * is going on, the Push should be processed after the Pull is completed.
 *
 * The sender will attempt to Push to the receiver. If the Push RPC fails more
 * than X times (a recommended retry count is 5), the event will be dispatched
 * to the sender's queue for the receiver. Unless the receiver pulls these events,
 * all new events should be dispatched to the queue. No new Push RPC should be made
 * before the queue is emptied. This ensures that events are always received in the
 * right order.
 *
 * It is recommended that receivers try pulling periodically, for example, every
 * 1 minute after the last Push RPC by the sender. This ensures that events are recieved.
 *
 * @generated from protobuf service protocol.sync.v1.PostboxService
 */
export interface IPostboxServiceClient {
    /**
     * Endpoint to pull events.
     *
     * @generated from protobuf rpc: Pull(protocol.sync.v1.PullRequest) returns (protocol.sync.v1.PullResponse);
     */
    pull(input: PullRequest, options?: RpcOptions): UnaryCall<PullRequest, PullResponse>;
    /**
     * Endpoint to push events.
     *
     * @generated from protobuf rpc: Push(protocol.sync.v1.PushRequest) returns (protocol.sync.v1.PushResponse);
     */
    push(input: PushRequest, options?: RpcOptions): UnaryCall<PushRequest, PushResponse>;
    /**
     * Endpoint to notify a server of a server ID change. It is called by the server
     * that had it's server ID changed for all servers it has federated with.
     *
     * @generated from protobuf rpc: NotifyNewId(protocol.sync.v1.NotifyNewIdRequest) returns (protocol.sync.v1.NotifyNewIdResponse);
     */
    notifyNewId(input: NotifyNewIdRequest, options?: RpcOptions): UnaryCall<NotifyNewIdRequest, NotifyNewIdResponse>;
}
/**
 * Type for protobuf message protocol.sync.v1.AuthData
 */
class AuthData$Type extends MessageType<AuthData> {
    constructor() {
        super("protocol.sync.v1.AuthData", [
            { no: 1, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const AuthData = new AuthData$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event
 */
class Event$Type extends MessageType<Event> {
    constructor() {
        super("protocol.sync.v1.Event", [
            { no: 1, name: "user_removed_from_guild", kind: "message", oneof: "kind", T: () => Event_UserRemovedFromGuild },
            { no: 2, name: "user_added_to_guild", kind: "message", oneof: "kind", T: () => Event_UserAddedToGuild }
        ]);
    }
}
export const Event = new Event$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event.UserRemovedFromGuild
 */
class Event_UserRemovedFromGuild$Type extends MessageType<Event_UserRemovedFromGuild> {
    constructor() {
        super("protocol.sync.v1.Event.UserRemovedFromGuild", [
            { no: 1, name: "user_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "guild_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const Event_UserRemovedFromGuild = new Event_UserRemovedFromGuild$Type();
/**
 * Type for protobuf message protocol.sync.v1.Event.UserAddedToGuild
 */
class Event_UserAddedToGuild$Type extends MessageType<Event_UserAddedToGuild> {
    constructor() {
        super("protocol.sync.v1.Event.UserAddedToGuild", [
            { no: 1, name: "user_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "guild_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
}
export const Event_UserAddedToGuild = new Event_UserAddedToGuild$Type();
/**
 * Type for protobuf message protocol.sync.v1.PullRequest
 */
class PullRequest$Type extends MessageType<PullRequest> {
    constructor() {
        super("protocol.sync.v1.PullRequest", []);
    }
}
export const PullRequest = new PullRequest$Type();
/**
 * Type for protobuf message protocol.sync.v1.PullResponse
 */
class PullResponse$Type extends MessageType<PullResponse> {
    constructor() {
        super("protocol.sync.v1.PullResponse", [
            { no: 1, name: "event_queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
}
export const PullResponse = new PullResponse$Type();
/**
 * Type for protobuf message protocol.sync.v1.PushRequest
 */
class PushRequest$Type extends MessageType<PushRequest> {
    constructor() {
        super("protocol.sync.v1.PushRequest", [
            { no: 1, name: "event", kind: "message", T: () => Event }
        ]);
    }
}
export const PushRequest = new PushRequest$Type();
/**
 * Type for protobuf message protocol.sync.v1.PushResponse
 */
class PushResponse$Type extends MessageType<PushResponse> {
    constructor() {
        super("protocol.sync.v1.PushResponse", []);
    }
}
export const PushResponse = new PushResponse$Type();
/**
 * Type for protobuf message protocol.sync.v1.NotifyNewIdRequest
 */
class NotifyNewIdRequest$Type extends MessageType<NotifyNewIdRequest> {
    constructor() {
        super("protocol.sync.v1.NotifyNewIdRequest", [
            { no: 1, name: "new_server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
export const NotifyNewIdRequest = new NotifyNewIdRequest$Type();
/**
 * Type for protobuf message protocol.sync.v1.NotifyNewIdResponse
 */
class NotifyNewIdResponse$Type extends MessageType<NotifyNewIdResponse> {
    constructor() {
        super("protocol.sync.v1.NotifyNewIdResponse", []);
    }
}
export const NotifyNewIdResponse = new NotifyNewIdResponse$Type();
/**
 * # Postbox
 *
 * The postbox service forms the core of Harmony's server <-> server communications.
 *
 * It concerns the transfer of Events between servers, as well as ensuring reliable
 * delivery of them.
 *
 * The semantics of events are documented in the event types. The postbox service
 * is solely reliable for reliable pushing and pulling.
 *
 * ## Server Identification
 *
 * Servers are identified using their domain, and the port which they serve. This is
 * called the "server ID", and must be formatted as `domain:port`. The port is NOT
 * optional. Converting this ID to a URL for communicating can simply be done via
 * prefixing the ID with a protocol, eg. `https://`.
 *
 * ## Authorisation
 *
 * Requests are authorised using a serialized `harmonytypes.v1.Token` in the Authorization HTTP header.
 * The `data` field of the token will be a serialized `AuthData` message.
 * The private key used to sign is the homeserver's private key.
 *
 * ## Events
 *
 * In this section, we will use sender and recipient to refer to the servers
 * sending the events and the server receiving the events respectively.
 *
 * At PostboxService startup, a sender should first Pull all receivers it had
 * federated from before. If a receiver makes a Push to the sender while a Pull
 * is going on, the Push should be processed after the Pull is completed.
 *
 * The sender will attempt to Push to the receiver. If the Push RPC fails more
 * than X times (a recommended retry count is 5), the event will be dispatched
 * to the sender's queue for the receiver. Unless the receiver pulls these events,
 * all new events should be dispatched to the queue. No new Push RPC should be made
 * before the queue is emptied. This ensures that events are always received in the
 * right order.
 *
 * It is recommended that receivers try pulling periodically, for example, every
 * 1 minute after the last Push RPC by the sender. This ensures that events are recieved.
 *
 * @generated from protobuf service protocol.sync.v1.PostboxService
 */
export class PostboxServiceClient implements IPostboxServiceClient {
    readonly typeName = "protocol.sync.v1.PostboxService";
    readonly methods: MethodInfo[] = [
        { service: this, name: "Pull", localName: "pull", I: PullRequest, O: PullResponse },
        { service: this, name: "Push", localName: "push", I: PushRequest, O: PushResponse },
        { service: this, name: "NotifyNewId", localName: "notifyNewId", I: NotifyNewIdRequest, O: NotifyNewIdResponse }
    ];
    constructor(private readonly _transport: RpcTransport) {
    }
    pull(input: PullRequest, options?: RpcOptions): UnaryCall<PullRequest, PullResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<PullRequest, PullResponse>("unary", this._transport, method, opt, i);
    }
    push(input: PushRequest, options?: RpcOptions): UnaryCall<PushRequest, PushResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<PushRequest, PushResponse>("unary", this._transport, method, opt, i);
    }
    notifyNewId(input: NotifyNewIdRequest, options?: RpcOptions): UnaryCall<NotifyNewIdRequest, NotifyNewIdResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options), i = method.I.create(input);
        return stackIntercept<NotifyNewIdRequest, NotifyNewIdResponse>("unary", this._transport, method, opt, i);
    }
}
