// @generated by protobuf-ts 2.0.6 with parameter long_type_string,optimize_code_size,generate_dependencies,optimize_code_size
// @generated from protobuf file "auth/v1/auth.proto" (package "protocol.auth.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { AuthService } from "./auth";
import type { CheckLoggedInResponse } from "./auth";
import type { CheckLoggedInRequest } from "./auth";
import type { StreamStepsResponse } from "./auth";
import type { StreamStepsRequest } from "./auth";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { StepBackResponse } from "./auth";
import type { StepBackRequest } from "./auth";
import type { NextStepResponse } from "./auth";
import type { NextStepRequest } from "./auth";
import type { BeginAuthResponse } from "./auth";
import type { BeginAuthRequest } from "./auth";
import type { KeyResponse } from "./auth";
import type { KeyRequest } from "./auth";
import type { LoginFederatedResponse } from "./auth";
import type { LoginFederatedRequest } from "./auth";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { FederateResponse } from "./auth";
import type { FederateRequest } from "./auth";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
// # Federation
// 
// Servers should generate and persist an Ed25519 public and private
// key. These will be referred to later on simply as the public
// and private keys of the server.
// 
// Federate is the core of Harmony's federation model.
// The client sends the server name of the foreignserver
// to its homeserver using the Federate method.
// 
// The homeserver generates a `harmonytypes.v1.Token`, where the `data` field
// contains a serialized `TokenData` message.
// The private key used to sign is the homeserver's private key.
// 
// The target should be the foreignserver's server name.
// The user ID should be the client's user ID on the homeserver.
// The username and avatar should be the client's username and avatar,
// so the foreignserver knows what username and avatar to give them.
// 
// The client will use this token in a LoginFederatedRequest request
// and send it to the foreignserver as the auth_token field, with the
// domain field filled out to the server name of the homeserver.
// 
// TODO: finish

/**
 * The service containing authorization/entication methods
 *
 * @generated from protobuf service protocol.auth.v1.AuthService
 */
export interface IAuthServiceClient {
    /**
     * Federate with a foreignserver, obtaining a token
     * you can use to call LoginFederated on it
     *
     * @generated from protobuf rpc: Federate(protocol.auth.v1.FederateRequest) returns (protocol.auth.v1.FederateResponse);
     */
    federate(input: FederateRequest, options?: RpcOptions): UnaryCall<FederateRequest, FederateResponse>;
    /**
     * Present a token to a foreignserver from a Federate call
     * on your homeserver in order to login
     *
     * @generated from protobuf rpc: LoginFederated(protocol.auth.v1.LoginFederatedRequest) returns (protocol.auth.v1.LoginFederatedResponse);
     */
    loginFederated(input: LoginFederatedRequest, options?: RpcOptions): UnaryCall<LoginFederatedRequest, LoginFederatedResponse>;
    /**
     * Returns the public key of this server
     *
     * @generated from protobuf rpc: Key(protocol.auth.v1.KeyRequest) returns (protocol.auth.v1.KeyResponse);
     */
    key(input: KeyRequest, options?: RpcOptions): UnaryCall<KeyRequest, KeyResponse>;
    /**
     * Begins an authentication session
     *
     * @generated from protobuf rpc: BeginAuth(protocol.auth.v1.BeginAuthRequest) returns (protocol.auth.v1.BeginAuthResponse);
     */
    beginAuth(input: BeginAuthRequest, options?: RpcOptions): UnaryCall<BeginAuthRequest, BeginAuthResponse>;
    /**
     * Goes to the next step of the authentication session,
     * possibly presenting user input
     *
     * @generated from protobuf rpc: NextStep(protocol.auth.v1.NextStepRequest) returns (protocol.auth.v1.NextStepResponse);
     */
    nextStep(input: NextStepRequest, options?: RpcOptions): UnaryCall<NextStepRequest, NextStepResponse>;
    /**
     * Goes to the previous step of the authentication session
     * if possible
     *
     * @generated from protobuf rpc: StepBack(protocol.auth.v1.StepBackRequest) returns (protocol.auth.v1.StepBackResponse);
     */
    stepBack(input: StepBackRequest, options?: RpcOptions): UnaryCall<StepBackRequest, StepBackResponse>;
    /**
     * Consume the steps of an authentication session
     * as a stream
     *
     * @generated from protobuf rpc: StreamSteps(protocol.auth.v1.StreamStepsRequest) returns (stream protocol.auth.v1.StreamStepsResponse);
     */
    streamSteps(input: StreamStepsRequest, options?: RpcOptions): ServerStreamingCall<StreamStepsRequest, StreamStepsResponse>;
    /**
     * Check whether or not you're logged in and the session is valid
     *
     * @generated from protobuf rpc: CheckLoggedIn(protocol.auth.v1.CheckLoggedInRequest) returns (protocol.auth.v1.CheckLoggedInResponse);
     */
    checkLoggedIn(input: CheckLoggedInRequest, options?: RpcOptions): UnaryCall<CheckLoggedInRequest, CheckLoggedInResponse>;
}
// # Federation
// 
// Servers should generate and persist an Ed25519 public and private
// key. These will be referred to later on simply as the public
// and private keys of the server.
// 
// Federate is the core of Harmony's federation model.
// The client sends the server name of the foreignserver
// to its homeserver using the Federate method.
// 
// The homeserver generates a `harmonytypes.v1.Token`, where the `data` field
// contains a serialized `TokenData` message.
// The private key used to sign is the homeserver's private key.
// 
// The target should be the foreignserver's server name.
// The user ID should be the client's user ID on the homeserver.
// The username and avatar should be the client's username and avatar,
// so the foreignserver knows what username and avatar to give them.
// 
// The client will use this token in a LoginFederatedRequest request
// and send it to the foreignserver as the auth_token field, with the
// domain field filled out to the server name of the homeserver.
// 
// TODO: finish

/**
 * The service containing authorization/entication methods
 *
 * @generated from protobuf service protocol.auth.v1.AuthService
 */
export class AuthServiceClient implements IAuthServiceClient, ServiceInfo {
    typeName = AuthService.typeName;
    methods = AuthService.methods;
    options = AuthService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Federate with a foreignserver, obtaining a token
     * you can use to call LoginFederated on it
     *
     * @generated from protobuf rpc: Federate(protocol.auth.v1.FederateRequest) returns (protocol.auth.v1.FederateResponse);
     */
    federate(input: FederateRequest, options?: RpcOptions): UnaryCall<FederateRequest, FederateResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<FederateRequest, FederateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Present a token to a foreignserver from a Federate call
     * on your homeserver in order to login
     *
     * @generated from protobuf rpc: LoginFederated(protocol.auth.v1.LoginFederatedRequest) returns (protocol.auth.v1.LoginFederatedResponse);
     */
    loginFederated(input: LoginFederatedRequest, options?: RpcOptions): UnaryCall<LoginFederatedRequest, LoginFederatedResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<LoginFederatedRequest, LoginFederatedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Returns the public key of this server
     *
     * @generated from protobuf rpc: Key(protocol.auth.v1.KeyRequest) returns (protocol.auth.v1.KeyResponse);
     */
    key(input: KeyRequest, options?: RpcOptions): UnaryCall<KeyRequest, KeyResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<KeyRequest, KeyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Begins an authentication session
     *
     * @generated from protobuf rpc: BeginAuth(protocol.auth.v1.BeginAuthRequest) returns (protocol.auth.v1.BeginAuthResponse);
     */
    beginAuth(input: BeginAuthRequest, options?: RpcOptions): UnaryCall<BeginAuthRequest, BeginAuthResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<BeginAuthRequest, BeginAuthResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Goes to the next step of the authentication session,
     * possibly presenting user input
     *
     * @generated from protobuf rpc: NextStep(protocol.auth.v1.NextStepRequest) returns (protocol.auth.v1.NextStepResponse);
     */
    nextStep(input: NextStepRequest, options?: RpcOptions): UnaryCall<NextStepRequest, NextStepResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<NextStepRequest, NextStepResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Goes to the previous step of the authentication session
     * if possible
     *
     * @generated from protobuf rpc: StepBack(protocol.auth.v1.StepBackRequest) returns (protocol.auth.v1.StepBackResponse);
     */
    stepBack(input: StepBackRequest, options?: RpcOptions): UnaryCall<StepBackRequest, StepBackResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<StepBackRequest, StepBackResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Consume the steps of an authentication session
     * as a stream
     *
     * @generated from protobuf rpc: StreamSteps(protocol.auth.v1.StreamStepsRequest) returns (stream protocol.auth.v1.StreamStepsResponse);
     */
    streamSteps(input: StreamStepsRequest, options?: RpcOptions): ServerStreamingCall<StreamStepsRequest, StreamStepsResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamStepsRequest, StreamStepsResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Check whether or not you're logged in and the session is valid
     *
     * @generated from protobuf rpc: CheckLoggedIn(protocol.auth.v1.CheckLoggedInRequest) returns (protocol.auth.v1.CheckLoggedInResponse);
     */
    checkLoggedIn(input: CheckLoggedInRequest, options?: RpcOptions): UnaryCall<CheckLoggedInRequest, CheckLoggedInResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<CheckLoggedInRequest, CheckLoggedInResponse>("unary", this._transport, method, opt, input);
    }
}
