// @generated by protobuf-ts 1.0.12 with parameters long_type_string,optimize_code_size,generate_dependencies
// @generated from protobuf file "voice/v1/voice.proto" (package "protocol.voice.v1", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { MethodInfo } from "@protobuf-ts/runtime-rpc";
import { MessageType } from "@protobuf-ts/runtime";
import { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { UnaryCall } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
import { Empty } from "../../google/protobuf/empty";
/**
 * @generated from protobuf message protocol.voice.v1.Signal
 */
export interface Signal {
  /**
   * @generated from protobuf oneof: event
   */
  event:
    | {
        oneofKind: "iceCandidate";
        /**
         * @generated from protobuf field: string ice_candidate = 1;
         */
        iceCandidate: string;
      }
    | {
        oneofKind: "renegotiationNeeded";
        /**
         * @generated from protobuf field: google.protobuf.Empty renegotiation_needed = 2;
         */
        renegotiationNeeded: Empty;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message protocol.voice.v1.ConnectRequest
 */
export interface ConnectRequest {
  /**
   * @generated from protobuf field: uint64 channel_id = 1;
   */
  channelId: string;
  /**
   * @generated from protobuf field: string offer = 2;
   */
  offer: string;
}
/**
 * @generated from protobuf message protocol.voice.v1.ConnectResponse
 */
export interface ConnectResponse {
  /**
   * @generated from protobuf field: string answer = 1;
   */
  answer: string;
}
/**
 * @generated from protobuf message protocol.voice.v1.StreamStateRequest
 */
export interface StreamStateRequest {
  /**
   * @generated from protobuf field: uint64 channel_id = 1;
   */
  channelId: string;
}
/**
 * @generated from protobuf service protocol.voice.v1.VoiceService
 */
export interface IVoiceServiceClient {
  /**
   * @generated from protobuf rpc: Connect(protocol.voice.v1.ConnectRequest) returns (protocol.voice.v1.ConnectResponse);
   */
  connect(
    input: ConnectRequest,
    options?: RpcOptions
  ): UnaryCall<ConnectRequest, ConnectResponse>;
  /**
   * @generated from protobuf rpc: StreamState(protocol.voice.v1.StreamStateRequest) returns (stream protocol.voice.v1.Signal);
   */
  streamState(
    input: StreamStateRequest,
    options?: RpcOptions
  ): ServerStreamingCall<StreamStateRequest, Signal>;
}
/**
 * Type for protobuf message protocol.voice.v1.Signal
 */
class Signal$Type extends MessageType<Signal> {
  constructor() {
    super("protocol.voice.v1.Signal", [
      {
        no: 1,
        name: "ice_candidate",
        kind: "scalar",
        oneof: "event",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "renegotiation_needed",
        kind: "message",
        oneof: "event",
        T: () => Empty,
      },
    ]);
  }
}
export const Signal = new Signal$Type();
/**
 * Type for protobuf message protocol.voice.v1.ConnectRequest
 */
class ConnectRequest$Type extends MessageType<ConnectRequest> {
  constructor() {
    super("protocol.voice.v1.ConnectRequest", [
      { no: 1, name: "channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
      { no: 2, name: "offer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
}
export const ConnectRequest = new ConnectRequest$Type();
/**
 * Type for protobuf message protocol.voice.v1.ConnectResponse
 */
class ConnectResponse$Type extends MessageType<ConnectResponse> {
  constructor() {
    super("protocol.voice.v1.ConnectResponse", [
      { no: 1, name: "answer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
}
export const ConnectResponse = new ConnectResponse$Type();
/**
 * Type for protobuf message protocol.voice.v1.StreamStateRequest
 */
class StreamStateRequest$Type extends MessageType<StreamStateRequest> {
  constructor() {
    super("protocol.voice.v1.StreamStateRequest", [
      { no: 1, name: "channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
    ]);
  }
}
export const StreamStateRequest = new StreamStateRequest$Type();
/**
 * @generated from protobuf service protocol.voice.v1.VoiceService
 */
export class VoiceServiceClient implements IVoiceServiceClient {
  readonly typeName = "protocol.voice.v1.VoiceService";
  readonly methods: MethodInfo[] = [
    {
      service: this,
      name: "Connect",
      localName: "connect",
      I: ConnectRequest,
      O: ConnectResponse,
    },
    {
      service: this,
      name: "StreamState",
      localName: "streamState",
      I: StreamStateRequest,
      O: Signal,
      serverStreaming: true,
    },
  ];
  constructor(private readonly _transport: RpcTransport) {}
  connect(
    input: ConnectRequest,
    options?: RpcOptions
  ): UnaryCall<ConnectRequest, ConnectResponse> {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options),
      i = method.I.create(input);
    return stackIntercept<ConnectRequest, ConnectResponse>(
      "unary",
      this._transport,
      method,
      opt,
      i
    );
  }
  streamState(
    input: StreamStateRequest,
    options?: RpcOptions
  ): ServerStreamingCall<StreamStateRequest, Signal> {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options),
      i = method.I.create(input);
    return stackIntercept<StreamStateRequest, Signal>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      i
    );
  }
}
